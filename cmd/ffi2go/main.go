package main

import (
	_ "embed"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"github.com/Zyko0/go-sdl3/cmd/internal/assets"
	"github.com/dave/jennifer/jen"
)

var (
	cfg        *assets.Config
	ffiEntries []*assets.FFIEntry
	apiRefCode string
)

const (
	genComment = "// Code generated by cmd/ffi2go. DO NOT EDIT.\n"
)

var (
	typesConversions = map[string]string{
		"_Bool":          "bool", // TODO: SDLBool
		"int":            "int",
		"Sint8":          "int8",
		"Sint16":         "int16",
		"Sint32":         "int32",
		"Sint64":         "int64",
		"Uint8":          "uint8",
		"Uint16":         "uint16",
		"Uint32":         "uint32",
		"Uint64":         "uint64",
		"long":           "int64",
		"float":          "float32",
		"double":         "float64",
		"unsigned-short": "uint16",
		"unsigned-int":   "uint",
		"unsigned-long":  "uint64",
		"long-long":      "int64",
		"ulong":          "uint64",
		"size_t":         "uintptr",
		"wchar_t":        "byte",
		"intptr_t":       "int64",
		"char":           "char", // Note: this allows replacing char* with string
		"unsigned-char":  "byte",
		"void":           "void",
		//"pointer":          "uintptr",
		"function-pointer": "uintptr",
	}
)

func sanitizeVarName(s string) string {
	var b strings.Builder
	nextCap := true
	for _, r := range s {
		if nextCap && r >= 'a' && r <= 'z' {
			r -= 32
		}
		nextCap = false
		if r == '_' {
			nextCap = true
		} else {
			b.WriteRune(r)
		}
	}

	return b.String()
}

func sanitizeArgName(s string) string {
	switch s {
	case "func":
		return "function"
	case "type":
		return "typ"
	case "chan":
		return "chann"
	default:
		return s
	}
}

func convType(s string, bitSize int) string {
	s = strings.ReplaceAll(s, ":", "")
	if ret, ok := typesConversions[s]; ok {
		switch ret {
		case "int", "uint":
			return fmt.Sprintf("%s%d", s, bitSize)
		default:
			return ret
		}
	}
	if cfg.LibraryName != "sdl" && strings.HasPrefix(s, "SDL_") {
		return "sdl." + s[4:]
	}
	return s
}

func postConvertType(s string) string {
	switch s {
	case "*char":
		return "string"
	case "*void":
		return "uintptr"
	default:
		return s
	}
}

func extractType(e *assets.FFIEntry) (typ string, prefix bool) {
	switch e.Tag {
	case ":array":
		typ, prefix = extractType(e.Type)
		typ = fmt.Sprintf("[%d]", e.Size) + typ
	case ":function-pointer":
		typ = "uintptr"
		prefix = false
	case ":pointer":
		typ, prefix = extractType(e.Type)
		typ = "*" + typ
	case ":struct", "struct":
		typ = e.Name
		prefix = e.SymbolHasPrefix
	default:
		typ = convType(e.Tag, e.BitSize)
		prefix = e.TagHasPrefix
	}

	return postConvertType(typ), prefix
}

func trimPrefix(e *assets.FFIEntry) {
	if strings.HasPrefix(e.Tag, cfg.Prefix) {
		e.TagHasPrefix = true
	}
	e.Tag = strings.TrimPrefix(e.Tag, cfg.Prefix)
	if strings.HasPrefix(e.Name, cfg.Prefix) {
		e.SymbolHasPrefix = true
	}
	e.Name = strings.TrimPrefix(e.Name, cfg.Prefix)
	if e.Type != nil {
		trimPrefix(e.Type)
	}
	if e.ReturnType != nil {
		trimPrefix(e.ReturnType)
	}
	for _, ee := range e.Fields {
		trimPrefix(ee)
	}
	for _, ee := range e.Parameters {
		trimPrefix(ee)
	}
}

type refFunc struct {
	Name        string
	Description string
}

var (
	uniqueTypes        = map[string]struct{}{}
	uniqueAPIFunctions = map[string]refFunc{}
)

func AllTypesFromAPIRef() {
	for _, l := range strings.Split(apiRefCode, "\n") {
		l = strings.TrimSpace(l)
		l = strings.ReplaceAll(l, "const ", "")
		l = strings.ReplaceAll(l, " * ", "* ")
		l = strings.ReplaceAll(l, " ** ", "** ")
		l = strings.ReplaceAll(l, "* * ", "** ")
		switch {
		case strings.HasPrefix(l, "//"):
			continue
		case strings.HasPrefix(l, "#"):
			continue
		case l == "":
			continue
		default:
			idx := strings.Index(l, "//")
			comment := ""
			if idx != -1 {
				comment = strings.TrimSpace(l[idx+2:])
				comment = strings.TrimSuffix(comment, "\n")
				l = l[:idx]
			}
			// Parse function prototype
			nameIdx := strings.Index(l[1:], cfg.Prefix)
			// Function name
			name := l[nameIdx+1 : strings.Index(l, "(")]
			// Function comment
			comment = name + " => " + comment
			uniqueAPIFunctions[name] = refFunc{
				Name:        name,
				Description: comment,
			}
			// Return type
			typ := strings.TrimSpace(l[:nameIdx])
			typ = strings.ReplaceAll(typ, "*", "")
			uniqueTypes[typ] = struct{}{}
			// Argument types
			args := l[strings.Index(l, "(")+1 : strings.Index(l, ")")]
			argsParts := strings.Split(args, ", ")
			for _, at := range argsParts {
				argParts := strings.Split(at, " ")
				typ = strings.TrimSpace(strings.Join(argParts[:len(argParts)-1], " "))
				typ = strings.ReplaceAll(typ, "*", "")
				typ = strings.ReplaceAll(typ, "struct ", "")
				uniqueTypes[typ] = struct{}{}
			}
		}
	}
	for tp := range uniqueTypes {
		var found bool
		for _, prefix := range cfg.AllowlistedTypePrefixes {
			if strings.HasPrefix(tp, prefix) {
				found = true
				break
			}
		}
		if !found {
			delete(uniqueTypes, tp)
		}
	}
}

func jenType(stmt *jen.Statement, typ string) *jen.Statement {
	if strings.Contains(typ, ".") {
		var prefix string
		parts := strings.SplitN(typ, ".", 2)
		idx := strings.LastIndexAny(parts[0], "]*")
		if idx != -1 {
			prefix = parts[0][:idx+1]
			parts[0] = parts[0][idx+1:]
		}
		path := parts[0]
		if path == "sdl" {
			path = "github.com/Zyko0/go-sdl3/sdl"
		}
		if prefix != "" {
			stmt.Id(prefix).Qual(path, parts[1])
		} else {
			stmt.Qual(path, parts[1])
		}
	} else {
		stmt.Id(typ)
	}

	return stmt
}

func conditionalPrepend(head, tail string, cond bool) string {
	if cond {
		return head + tail
	}

	return tail
}

func main() {
	var configPath, ffiPath, annotationsPath string

	flag.StringVar(&configPath, "config", "", "path to config.json file")
	flag.StringVar(&ffiPath, "ffi", "", "path to ffi.json file")
	flag.StringVar(&annotationsPath, "annotations", "", "path to annotations.csv file")
	flag.Parse()

	// Load config
	var err error
	cfg, err = assets.LoadConfig(configPath)
	if err != nil {
		log.Fatal("couldn't parse config file: ", err)
	}

	// Parse FFI
	b, err := os.ReadFile(ffiPath)
	if err != nil {
		log.Fatal("couldn't read ffi.json file: ", err)
	}
	err = json.Unmarshal(b, &ffiEntries)
	if err != nil {
		log.Fatal("couldn't unmarshal ffi file: ", err)
	}

	// Load wiki annotations
	wikiEntries, err := assets.LoadWikiAnnotations(annotationsPath)
	if err != nil {
		log.Fatal("couldn't load wiki annotations file: ", err)
	}

	// Download API ref code
	resp, err := http.Get(cfg.QuickAPIRefURL)
	if err != nil {
		log.Fatal("couldn't download api ref: ", err)
	}
	b, err = io.ReadAll(resp.Body)
	if err != nil {
		log.Fatal("couldn't read http response body: ", err)
	}
	apiRefCode = string(b)
	_, apiRefCode, _ = strings.Cut(apiRefCode, "```c")
	apiRefCode, _, _ = strings.Cut(apiRefCode, "```")

	dir, err := os.Getwd()
	if err != nil {
		log.Fatal("err: ", err)
	}
	dir = filepath.Join(dir, cfg.OutDir)

	// Init all types and functions from SDL3 quick reference
	AllTypesFromAPIRef()

	// Filter and sanitize sdl entries
	n := 0
	for _, e := range ffiEntries {
		if !strings.HasPrefix(e.Location, cfg.AllowedInclude) {
			continue
		}
		// Trim prefixes
		trimPrefix(e)
		var allowlisted bool
		if e.Tag == "function" {
			allowlisted = slices.Contains(cfg.AllowlistedFunctions, e.PrefixedName(cfg.Prefix))
			if !allowlisted {
				if slices.Contains(cfg.IgnoredFunctions, e.PrefixedName(cfg.Prefix)) {
					continue
				}
				// Skip lower case functions
				if e.Name[0] >= 'a' && e.Name[0] <= 'z' {
					continue
				}
			}
		}
		// Skip some headers
		if !allowlisted {
			base, _, _ := strings.Cut(filepath.Base(e.Location), ":")
			if slices.Contains(cfg.IgnoredHeaders, base) {
				continue
			}
		}

		ffiEntries[n] = e
		n++
	}
	ffiEntries = ffiEntries[:n]

	// Register used types
	var regUsedTypes = func(e *assets.FFIEntry) bool {
		var registration bool
		for _, f := range e.Fields {
			// Remove pointer or array potential prefix
			t, prefix := extractType(f.Type)
			t = strings.ReplaceAll(t, "*", "")
			if idx := strings.Index(t, "]"); idx != -1 {
				t = t[idx+1:]
			}
			if _, ok := uniqueTypes[conditionalPrepend(cfg.Prefix, t, prefix)]; !ok {
				uniqueTypes[conditionalPrepend(cfg.Prefix, t, prefix)] = struct{}{}
				registration = true
			}
		}
		return registration
	}
	var done bool
	for !done {
		done = true
		for _, e := range ffiEntries {
			_, ok := uniqueTypes[e.PrefixedName(cfg.Prefix)]
			ok = ok || slices.Contains(cfg.BaseTypes, e.PrefixedName(cfg.Prefix))
			if ok {
				switch e.Tag {
				case "struct", "union":
					if registration := regUsedTypes(e); registration {
						done = false
					}
				case "typedef":
					if _, ok := uniqueTypes[cfg.Prefix+e.Tag]; !ok {
						t, prefix := extractType(e.Type)
						t = strings.ReplaceAll(t, "*", "")
						if idx := strings.Index(t, "]"); idx != -1 {
							t = t[idx+1:]
						}
						if _, ok := uniqueTypes[conditionalPrepend(cfg.Prefix, t, prefix)]; !ok {
							uniqueTypes[conditionalPrepend(cfg.Prefix, t, prefix)] = struct{}{}
							done = false
						}
					}
				}
			}
		}
	}

	fmt.Println("count entries:", len(ffiEntries))

	found := 0
	// Functions
	apifuncs := map[string]struct{}{}
	f := jen.NewFile(cfg.LibraryName)
	f.Comment(genComment)
	f.Var().DefsFunc(func(g *jen.Group) {
		g.Comment(fmt.Sprintf("//puregogen:library path:windows=%s.dll path:unix=%s.so alias=%s",
			cfg.LibraryName, cfg.LibraryName, cfg.LibraryName,
		))
		for _, e := range ffiEntries {
			if e.Tag != "function" || e.Inline {
				continue
			}
			if ref, ok := uniqueAPIFunctions[e.PrefixedName(cfg.Prefix)]; ok {
				found++
				apifuncs[e.Name] = struct{}{}
				// Only add once
				fn := jen.Id("i" + e.Name).Func()
				fn.ParamsFunc(func(h *jen.Group) {
					for _, ee := range e.Parameters {
						typ, _ := extractType(ee.Type)
						if slices.Contains(cfg.NoAutoStringFunctions, e.PrefixedName(cfg.Prefix)) &&
							strings.HasSuffix(typ, "string") {
							typ = strings.ReplaceAll(typ, "string", "*byte")
						}
						h.Add(
							jenType(jen.Id(sanitizeArgName(ee.Name)), typ),
						)
					}
				})
				if e.ReturnType != nil && e.ReturnType.Tag != ":void" {
					if slices.Contains(cfg.SDLFreeFunctions, e.PrefixedName(cfg.Prefix)) {
						fn.Uintptr()
					} else {
						t, _ := extractType(e.ReturnType)
						if slices.Contains(cfg.NoAutoStringFunctions, e.PrefixedName(cfg.Prefix)) &&
							strings.HasSuffix(t, "string") {
							t = strings.ReplaceAll(t, "string", "*byte")
						}
						jenType(fn, t)
					}
				}
				if e.SymbolHasPrefix {
					g.Add(jen.Comment(
						"//puregogen:function symbol=" + cfg.Prefix + e.Name,
					))
				}
				g.Add(jen.Comment(
					"// " + ref.Description,
				))
				if slices.Contains(cfg.SDLFreeFunctions, e.PrefixedName(cfg.Prefix)) {
					g.Add(jen.Comment(
						"// SDL_free() must be called on the returned pointer.",
					))
				}
				g.Add(fn.Line())
			}
		}
	})
	outputFileLocation := filepath.Join(dir, cfg.LibraryName+"_functions.gen.go")
	err = os.WriteFile(outputFileLocation, []byte(f.GoString()), 0666)
	if err != nil {
		log.Fatalf("couldn't write file %s: %v", outputFileLocation, err)
	}

	// Enums
	f = jen.NewFile(cfg.LibraryName)
	f.Comment(genComment)
	for _, e := range ffiEntries {
		if e.Tag != "enum" {
			continue
		}
		if _, ok := uniqueTypes[e.PrefixedName(cfg.Prefix)]; !ok {
			continue
		}
		if wikiEntry, ok := wikiEntries[e.PrefixedName(cfg.Prefix)]; ok {
			f.Comment(fmt.Sprintf(
				"// %s - %s", wikiEntry.Name, wikiEntry.Description,
			))
			f.Comment(fmt.Sprintf(
				"// (%s)", wikiEntry.URL,
			))
		}
		f.Type().Id(e.Name).Uint32()
		f.Const().DefsFunc(func(g *jen.Group) {
			for _, ee := range e.Fields {
				stmt := jen.Id(ee.Name).Id(e.Name).Op("=").Lit(ee.Value)
				if wikiEntry, ok := wikiEntries[ee.PrefixedName(cfg.Prefix)]; ok {
					stmt.Comment(fmt.Sprintf(
						"// %s", wikiEntry.Description,
					))
				}
				g.Add(stmt)
			}
		})
	}
	outputFileLocation = filepath.Join(dir, cfg.LibraryName+"_enums.gen.go")
	err = os.WriteFile(outputFileLocation, []byte(f.GoString()), 0666)
	if err != nil {
		log.Fatalf("couldn't write file %s: %v", outputFileLocation, err)
	}

	// Structs
	f = jen.NewFile(cfg.LibraryName)
	f.Comment(genComment)
	for _, e := range ffiEntries {
		if e.Tag != "struct" {
			continue
		}
		if slices.Contains(cfg.IgnoredTypes, e.Name) {
			continue
		}
		if _, ok := uniqueTypes[e.PrefixedName(cfg.Prefix)]; !ok {
			continue
		}
		if wikiEntry, ok := wikiEntries[e.PrefixedName(cfg.Prefix)]; ok {
			f.Comment(fmt.Sprintf(
				"// %s - %s", wikiEntry.Name, wikiEntry.Description,
			))
			f.Comment(fmt.Sprintf(
				"// (%s)", wikiEntry.URL,
			))
		}
		f.Type().Id(e.Name).StructFunc(func(g *jen.Group) {
			for i, ee := range e.Fields {
				typ, _ := extractType(ee.Type)
				// Replacement for structs only to account for offset/alignment in wasm
				if typ == "uintptr" {
					typ = "Pointer"
				}
				stmt := jenType(jen.Id(sanitizeVarName(ee.Name)), typ)
				if wikiEntry, ok := wikiEntries[fmt.Sprintf("%s.%d", e.PrefixedName(cfg.Prefix), i)]; ok {
					stmt.Comment(fmt.Sprintf(
						"// %s", wikiEntry.Description,
					))
				}
				g.Add(stmt)
			}
		}).Line()
	}
	outputFileLocation = filepath.Join(dir, cfg.LibraryName+"_structs.gen.go")
	err = os.WriteFile(outputFileLocation, []byte(f.GoString()), 0666)
	if err != nil {
		log.Fatalf("couldn't write file %s: %v", outputFileLocation, err)
	}

	// Types
	f = jen.NewFile(cfg.LibraryName)
	f.Comment(genComment).Line()
	f.Do(func(stmt *jen.Statement) {
		for _, e := range ffiEntries {
			switch {
			case e.Tag != "typedef",
				e.Type.Tag == ":struct", e.Type.Tag == "struct",
				e.Type.Tag == ":enum",
				e.Type.Tag == ":union", e.Type.Tag == "union",
				e.Type.Tag == ":function-pointer":
				continue
			}
			if slices.Contains(cfg.IgnoredTypes, e.Name) {
				continue
			}
			if _, ok := uniqueTypes[e.PrefixedName(cfg.Prefix)]; !ok {
				continue
			}
			if _, handled := typesConversions[e.Name]; handled {
				continue
			}
			typ, _ := extractType(e.Type)
			if e.Name == typ {
				continue
			}
			if wikiEntry, ok := wikiEntries[e.PrefixedName(cfg.Prefix)]; ok {
				stmt.Comment(fmt.Sprintf(
					"// %s - %s", wikiEntry.Name, wikiEntry.Description,
				)).Line()
				stmt.Comment(fmt.Sprintf(
					"// (%s)", wikiEntry.URL,
				)).Line()
			}
			stmt.Add(
				// Add an extra line to allow documentation comments
				jenType(jen.Type().Id(e.Name), typ).Line().Line(),
			)
		}
	})
	outputFileLocation = filepath.Join(dir, cfg.LibraryName+"_types.gen.go")
	err = os.WriteFile(outputFileLocation, []byte(f.GoString()), 0666)
	if err != nil {
		log.Fatalf("couldn't write file %s: %v", outputFileLocation, err)
	}
}
